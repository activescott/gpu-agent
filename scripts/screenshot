#!/bin/bash
# Take screenshots of a page using Playwright.
# Optimized for AI/LLM analysis: automatically splits long pages into
# viewport-sized chunks so each image is readable at full resolution.
#
# Usage:
#   ./scripts/screenshot <url> [output-dir]
#   ./scripts/screenshot http://localhost:3000/gpu/market-report/gpu-market-report-february-2026
#   ./scripts/screenshot http://localhost:3000/gpu/market-report/gpu-market-report-february-2026 /tmp/report-shots
#   ./scripts/screenshot https://gpupoet.com/gpu/price-compare /tmp/price-shots
#
# Output:
#   Short pages:  <output-dir>/screenshot.png
#   Long pages:   <output-dir>/screenshot-1.png, screenshot-2.png, ...
#   Prints each file path to stdout (one per line) for easy consumption.
#
# Options (via environment variables):
#   WIDTH=1280     Viewport width (default: 1280)
#   HEIGHT=900     Viewport height (default: 900)
#   SELECTOR=      CSS selector to screenshot a specific element instead of the page

set -e

if [ -z "$1" ]; then
    echo "Usage: $0 <url> [output-dir]"
    echo ""
    echo "Examples:"
    echo "  $0 http://localhost:3000/gpu/market-report/gpu-market-report-february-2026"
    echo "  $0 http://localhost:3000/some/page /tmp/my-shots"
    echo ""
    echo "Environment variables:"
    echo "  WIDTH=1280      Viewport width"
    echo "  HEIGHT=900      Viewport height"
    echo "  SELECTOR=       CSS selector for element screenshot"
    exit 1
fi

url="$1"
output_dir="${2:-/tmp/screenshots}"
width="${WIDTH:-1280}"
height="${HEIGHT:-900}"
selector="${SELECTOR:-}"

mkdir -p "$output_dir"

script_dir="$(cd "$(dirname "$0")" && pwd)"
e2e_dir="$script_dir/../e2e-tests"

cd "$e2e_dir"

node -e "
const { chromium } = require('@playwright/test');
const path = require('path');

(async () => {
  const browser = await chromium.launch();
  const page = await browser.newPage({
    viewport: { width: ${width}, height: ${height} },
    deviceScaleFactor: 1,
  });
  await page.goto('${url}');
  await page.waitForLoadState('networkidle');

  // Scroll to bottom and back to trigger lazy-loaded content, then wait for
  // client-side JS (Chart.js, etc.) to render all charts and components.
  const fullHeight = await page.evaluate(() => document.documentElement.scrollHeight);
  await page.evaluate((h) => window.scrollTo(0, h), fullHeight);
  await new Promise(r => setTimeout(r, 2000));
  await page.evaluate(() => window.scrollTo(0, 0));
  await new Promise(r => setTimeout(r, 1000));

  const outputDir = '${output_dir}';
  const selector = '${selector}';

  if (selector) {
    const el = await page.locator(selector).first();
    const filePath = path.join(outputDir, 'screenshot.png');
    await el.screenshot({ path: filePath });
    console.log(filePath);
  } else {
    const pageHeight = await page.evaluate(() => document.documentElement.scrollHeight);
    const viewportHeight = ${height};

    if (pageHeight <= viewportHeight * 1.5) {
      const filePath = path.join(outputDir, 'screenshot.png');
      await page.screenshot({ path: filePath, fullPage: true });
      console.log(filePath);
    } else {
      // Scroll through the page and capture each viewport
      const overlap = 50;
      const step = viewportHeight - overlap;
      let i = 0;
      let y = 0;

      while (y < pageHeight - 1) {
        i++;
        await page.evaluate((scrollY) => window.scrollTo(0, scrollY), y);
        await new Promise(r => setTimeout(r, 200)); // let rendering settle
        const filePath = path.join(outputDir, 'screenshot-' + String(i) + '.png');
        await page.screenshot({ path: filePath });
        console.log(filePath);
        y += step;
      }
    }
  }

  await browser.close();
})();
"
