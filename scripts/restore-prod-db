#!/usr/bin/env bash
this_dir=$(cd $(dirname "$0"); pwd)
this_script=$(basename $0)
workspace_root=$(cd "$this_dir/.."; pwd)

set -euo pipefail

# Remote backup location
remote_host="nas.activescott.com"
remote_path="/mnt/thedatapool/app-data/coinpoet/prod/db-backups"
local_backup_dir="$workspace_root/data/prod-backups"

# Database credentials (matches k8s/overlays/dev/.env.dev.db)
db_user="gpu_agent"
db_name="gpu_agent"
namespace="gpupoet-dev"

help () {
  cat << END_DOC
USAGE: $this_script [OPTIONS]

Restores the latest production database backup to the local dev environment.

Options:
  -h, --help    Show this help message

Prerequisites:
  - Dev environment running (./scripts/dev)
  - SSH access to nas.activescott.com

END_DOC
}

die () {
    echo "*** ERROR ***"
    echo >&2 "ERROR: $@"
    exit 1
}

check_minikube() {
    if ! command -v minikube &> /dev/null; then
        die "minikube is not installed. Install it with: brew install minikube"
    fi
    if ! minikube status &> /dev/null; then
        die "minikube is not running. Start it with: ./scripts/dev"
    fi
}

check_db_pod() {
    if ! kubectl --context minikube get pod db-0 -n "$namespace" &> /dev/null; then
        die "Database pod not found. Is the dev server running? Start it with: ./scripts/dev"
    fi
}

# Parse arguments
case "${1:-}" in
    -h|--help)
        help
        exit 0
        ;;
esac

echo "=== Restore Production Database to Dev ==="
echo ""

# Check prerequisites
check_minikube
check_db_pod

# Create local backup directory
mkdir -p "$local_backup_dir"

# Find and download latest backup
echo "Finding latest backup on $remote_host..."
latest_backup=$(ssh "$remote_host" "ls -t '$remote_path'/db-*.dump | head -1")
if [[ -z "$latest_backup" ]]; then
    die "No backup files found on remote server"
fi
backup_filename=$(basename "$latest_backup")
echo "Latest backup: $backup_filename"
echo ""

# Download the backup
local_backup_path="$local_backup_dir/$backup_filename"
if [[ -f "$local_backup_path" ]]; then
    echo "Backup already exists locally: $local_backup_path"
else
    echo "Downloading backup..."
    rsync -avz --progress "$remote_host:$latest_backup" "$local_backup_path"
fi
echo ""

# Confirm before proceeding
echo "WARNING: This will replace all data in the local dev database!"
read -p "Continue? (yes/no): " confirm
if [[ "$confirm" != "yes" ]]; then
    echo "Aborted."
    exit 0
fi
echo ""

# Terminate existing connections and restore
echo "Terminating existing database connections..."
kubectl --context minikube exec db-0 -n "$namespace" -- psql -U "$db_user" -d postgres -c \
    "SELECT pg_terminate_backend(pid) FROM pg_stat_activity WHERE datname = '$db_name' AND pid <> pg_backend_pid();" \
    2>/dev/null || true

echo "Dropping and recreating database..."
kubectl --context minikube exec db-0 -n "$namespace" -- psql -U "$db_user" -d postgres -c "DROP DATABASE IF EXISTS $db_name;"
kubectl --context minikube exec db-0 -n "$namespace" -- psql -U "$db_user" -d postgres -c "CREATE DATABASE $db_name OWNER $db_user;"

echo "Restoring database from backup..."
# Use psql for plain text dumps (.dump files from pg_dump without --format=custom)
kubectl --context minikube exec -i db-0 -n "$namespace" -- psql -U "$db_user" -d "$db_name" < "$local_backup_path"

echo ""
echo "=== Applying pending migrations ==="
echo ""
# Get the app pod to run migrations
app_pod=$(kubectl --context minikube get pods -n "$namespace" -l app=app -o jsonpath='{.items[0].metadata.name}' 2>/dev/null)
if [[ -z "$app_pod" ]]; then
    echo "WARNING: No app pod found. You'll need to run migrations manually:"
    echo "  ./scripts/prisma-migrate migrate deploy"
else
    echo "Running prisma migrate deploy in pod $app_pod..."
    kubectl --context minikube exec "$app_pod" -n "$namespace" -- sh -c "cd /app/packages/web-app && npx prisma migrate deploy"
fi

echo ""
echo "=== Restore complete! ==="
echo ""
echo "Verify with: kubectl --context minikube exec -it -n $namespace db-0 -- psql -U $db_user -d $db_name -c 'SELECT COUNT(*) FROM \"Listing\";'"
